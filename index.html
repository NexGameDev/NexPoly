<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Classic Mini Monopoly â€” 600x600 Cream Board</title>
<style>
  :root{
    --board-size:600px;     /* actual board size (1:1 requested) */
    --bg-krem:#f4ecd8;      /* cream paper color */
    --line:#1f1f1f;         /* thin border color */
    --muted:#6b7280;
    --accent:#f59e0b;
    --pawn-border:#0b1220;
    /* property colors */
    --brown:#8b5a2b; --lightblue:#3aa0ff; --pink:#d06aa7; --orange:#f28c2b;
    --red:#e03b3b; --yellow:#f5d23b; --green:#2bb673; --blue:#1f4fb4;
    --cell-gap:4px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(#071223,#03121a);color:#071726;display:flex;align-items:center;justify-content:center;padding:18px}
  .page{width:100%;max-width:980px}
  .board-area{display:flex;flex-direction:column;align-items:center;gap:12px}
  /* Board container: fixed 600x600 but scales down on small screens via max-width */
  .board-wrap{width:var(--board-size);height:var(--board-size);background:var(--bg-krem);border:2px solid var(--line);box-shadow:0 8px 24px rgba(2,6,23,0.6);border-radius:8px;overflow:hidden;position:relative}
  @media (max-width:640px){
    .board-wrap{width:calc(100vw - 32px);height:calc(100vw - 32px)} /* scale to fit small screens */
  }

  /* 11x11 grid. center 9x9 is kept visually empty by overlay */
  .board{width:100%;height:100%;display:grid;grid-template-columns:repeat(11,1fr);grid-template-rows:repeat(11,1fr);gap:var(--cell-gap);padding:8px;background:transparent}
  .cell{background:transparent;border:1px solid transparent;border-radius:4px;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:4px;font-size:11px;min-width:0;min-height:0;overflow:hidden}
  /* tile panel content box (white-ish) */
  .tile{background:#fff;border:1px solid var(--line);width:100%;height:100%;display:flex;flex-direction:column;justify-content:space-between;padding:4px;border-radius:4px;box-shadow:0 1px 0 rgba(0,0,0,0.03)}
  .corner .tile{display:flex;align-items:center;justify-content:center;font-weight:700}
  .title{font-weight:700;font-size:12px;line-height:1;text-align:center;word-break:keep-all}
  .title.small{font-size:10px}
  .bar{height:10px;border-radius:3px;width:100%;margin-bottom:4px}
  .price{font-size:11px;color:var(--muted);text-align:center}
  .players-on{display:flex;gap:4px;justify-content:center;padding-top:6px;flex-wrap:wrap}
  .pawn{width:14px;height:14px;border-radius:50%;border:2px solid var(--pawn-border);box-shadow:0 1px 0 rgba(0,0,0,0.05)}

  /* center blank overlay (covers inner 9x9 visually) */
  .center-blank{position:absolute;left:8px + (1 * ((var(--board-size) - 16px - (10 * var(--cell-gap))) / 11));top:8px + (1 * ((var(--board-size) - 16px - (10 * var(--cell-gap))) / 11)); /* fallback; will reposition via JS */pointer-events:none}

  /* bottom UI (under board) */
  .ui{width:100%;margin-top:6px;background:transparent;display:flex;flex-direction:column;gap:8px;align-items:center}
  .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
  button{background:var(--accent);border:none;color:#071726;padding:10px 12px;border-radius:8px;font-weight:700;cursor:pointer}
  button.alt{background:#fff;border:1px solid var(--line;color:#071726);color:#071726}
  .info-row{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;align-items:center}
  .chip{background:#fff;border:1px solid var(--line);padding:8px 10px;border-radius:8px;font-weight:700;color:#071726;min-width:90px;text-align:center}
  .log{width:100%;max-width:var(--board-size);background:#fff;border:1px solid var(--line);border-radius:8px;padding:8px;height:160px;overflow:auto;font-size:13px;color:#071726}
  @media (max-width:640px){ .log{max-width:calc(100vw - 32px)} }

  /* small helpers to ensure single-line labels */
  .title.one-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
</style>
</head>
<body>
  <div class="page">
    <div class="board-area">
      <div class="board-wrap" id="boardWrap" aria-label="Monopoly board (600x600)">
        <div class="board" id="board"></div>
      </div>

      <!-- UI below the board -->
      <div class="ui">
        <div class="controls">
          <button id="rollBtn">Roll Dice</button>
          <button id="buyBtn">Buy</button>
          <button id="endBtn">End Turn</button>
          <button id="addAI" class="alt">Add CPU</button>
          <button id="reset" class="alt">Reset</button>
        </div>

        <div class="info-row">
          <div class="chip">Money: <span id="money">Rp 1500</span></div>
          <div class="chip">Turn: <span id="turn">-</span></div>
          <div class="chip">Dice: <span id="dice">-</span></div>
          <div class="chip">Tile: <span id="tileInfo">-</span></div>
        </div>

        <div class="log" id="log" aria-live="polite"></div>
      </div>
    </div>
  </div>

<script>
/* Full 11x11 board, 40 tiles on edges (10 per side), cream paper look, center left blank.
   - Board visual is 11 cols x 11 rows
   - Mapping positions 0..39 to edge coords
   - Labels abbreviated per your choice: Prop, Chance, Tax, Rail, Community, Jail, GoToJail, FreePark, GO
   - UI under board (money, turn, dice, log)
   - AI: CPU players make simple heuristic buy decisions
*/

/* ---------- Helpers & Config ---------- */
const BOARD_SIZE = 600;           // desired board pixel size (will scale on small screens)
const BOARD_ID = 'board';
const MAX_POS = 40;
const abbrevMap = {
  'Property':'Prop',
  'Income Tax':'Tax',
  'Luxury Tax':'Tax',
  'Community Chest':'Community',
  'Chance':'Chance',
  'Electric Company':'Rail', // simplified naming (we'll use Rail for rail/utility)
  'Free Parking':'FreePark',
  'Go To Jail':'GoToJail',
  'Just Visiting / Jail':'Jail',
  'Jail (Just Visiting)':'Jail',
  'Railroad':'Rail',
  'GO':'GO'
};

/* tiles that are special */
const specialMap = {
  0:{type:'go', name:'GO'},
  4:{type:'tax', name:'Income Tax'},
  7:{type:'chance', name:'Chance'},
  10:{type:'jail', name:'Jail'},
  12:{type:'utility', name:'Electric Company'},
  17:{type:'community', name:'Community Chest'},
  20:{type:'free', name:'Free Parking'},
  22:{type:'chance', name:'Chance'},
  30:{type:'gotojail', name:'Go To Jail'},
  33:{type:'community', name:'Community Chest'},
  36:{type:'chance', name:'Chance'}
};

/* color groups (roughly matching classic distribution) */
const colorGroups = {
  brown:[1,3],
  lightblue:[6,8,9],
  pink:[11,13,14],
  orange:[16,18,19],
  red:[21,23,24],
  yellow:[26,27,29],
  green:[31,32,34],
  blue:[37,38,39]
};

/* build properties array */
const properties = [];
for(let i=0;i<MAX_POS;i++){
  if(specialMap[i]){
    const s = specialMap[i];
    properties.push({
      id:i,
      name:s.name,
      price: s.type==='go' || s.type==='free' || s.type==='jail' ? 0 : (s.type==='tax'?200: 100 + i*5),
      rent: s.type==='tax'?0: Math.max(10, Math.floor((100 + i*5)/7)),
      owner:null,
      type:s.type
    });
  } else {
    properties.push({
      id:i,
      name:`Property ${i}`,
      price:100 + i*5,
      rent: Math.max(10, Math.floor((100 + i*5)/7)),
      owner:null,
      type:'property'
    });
  }
}

/* players initial */
let players = [
  {id:0,name:'You',color:'#ef4444',pos:0,money:1500,alive:true,isAI:false},
  {id:1,name:'CPU 1',color:'#3b82f6',pos:0,money:1500,alive:true,isAI:true}
];
let currentTurn = 0;
let diceValue = 0;

/* board dom */
const boardEl = document.getElementById(BOARD_ID);
const logEl = document.getElementById('log');

/* ---------- Grid / Render ---------- */
function makeGrid(){
  boardEl.innerHTML = '';
  for(let r=0;r<11;r++){
    for(let c=0;c<11;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.gridIndex = r*11 + c;
      boardEl.appendChild(cell);
    }
  }
  // center blank overlay handled with leaving inner cells empty (we'll not render tiles there)
}
makeGrid();

/* edge coords mapping for 40 positions */
function edgeCoords(){
  const coords = [];
  for(let x=0;x<11;x++) coords.push([0,x]);           // top 0..10
  for(let y=1;y<11;y++) coords.push([y,10]);         // right 1..10
  for(let x=9;x>=0;x--) coords.push([10,x]);         // bottom 9..0
  for(let y=9;y>=1;y--) coords.push([y,0]);          // left 9..1
  return coords;
}
const coords = edgeCoords();
const posToIndex = coords.map(([r,c]) => r*11 + c);

/* short label function: uses mapping then trims to fit */
function shortLabel(text, side){
  if(!text) return '';
  // apply mapping
  for(const key in abbrevMap){
    const re = new RegExp(key,'i');
    if(re.test(text)) text = text.replace(re, abbrevMap[key]);
  }
  // side influences max chars
  const maxChars = (side === 'top' || side === 'bottom') ? 14 : 8;
  if(text.length <= maxChars) return text;
  // try to take first word or words
  const parts = text.split(' ');
  if(parts.length > 1){
    let s = parts.map(p => p.slice(0,3)).join(' ');
    if(s.length <= maxChars) return s;
  }
  return text.slice(0, Math.max(0, maxChars - 1)) + 'â€¦';
}

/* find color group */
function findGroup(pos){
  for(const k in colorGroups) if(colorGroups[k].includes(pos)) return k;
  return null;
}
function groupColor(g){
  switch(g){
    case 'brown': return getComputedStyle(document.documentElement).getPropertyValue('--brown') || '#8b5a2b';
    case 'lightblue': return getComputedStyle(document.documentElement).getPropertyValue('--lightblue') || '#3aa0ff';
    case 'pink': return getComputedStyle(document.documentElement).getPropertyValue('--pink') || '#d06aa7';
    case 'orange': return getComputedStyle(document.documentElement).getPropertyValue('--orange') || '#f28c2b';
    case 'red': return getComputedStyle(document.documentElement).getPropertyValue('--red') || '#e03b3b';
    case 'yellow': return getComputedStyle(document.documentElement).getPropertyValue('--yellow') || '#f5d23b';
    case 'green': return getComputedStyle(document.documentElement).getPropertyValue('--green') || '#2bb673';
    case 'blue': return getComputedStyle(document.documentElement).getPropertyValue('--blue') || '#1f4fb4';
    default: return '#e5e7eb';
  }
}

/* render board tiles around edge; center left blank */
function renderBoard(){
  // clear every cell
  const cells = boardEl.querySelectorAll('.cell');
  cells.forEach(c => c.innerHTML = '');

  for(let pos=0; pos<MAX_POS; pos++){
    const gridIndex = posToIndex[pos];
    const cell = boardEl.children[gridIndex];
    if(!cell) continue;
    // tile wrapper
    const tile = document.createElement('div');
    tile.className = 'tile';
    // mark corner style
    if(pos % 10 === 0) cell.classList.add('corner');

    // color bar if in group
    const group = findGroup(pos);
    if(group){
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.background = groupColor(group);
      tile.appendChild(bar);
    } else {
      // small spacer to keep layout consistent
      const spacer = document.createElement('div'); spacer.style.height='10px'; spacer.style.marginBottom='4px';
      tile.appendChild(spacer);
    }

    const side = determineSide(pos);
    const label = document.createElement('div');
    label.className = 'title one-line';
    label.textContent = shortLabel(properties[pos].name, side);
    tile.appendChild(label);

    // show price or small note
    const bottom = document.createElement('div');
    bottom.style.width='100%';
    bottom.style.display='flex';
    bottom.style.flexDirection='column';
    bottom.style.alignItems='center';
    bottom.style.justifyContent='flex-end';
    if(properties[pos].price > 0){
      const price = document.createElement('div');
      price.className = 'price';
      price.textContent = 'Rp ' + properties[pos].price;
      bottom.appendChild(price);
    } else {
      const info = document.createElement('div');
      info.className = 'price';
      info.textContent = properties[pos].type === 'tax' ? 'Tax' : properties[pos].type === 'go' ? 'GO' : properties[pos].type;
      bottom.appendChild(info);
    }
    // players placeholder
    const playersHere = document.createElement('div');
    playersHere.className = 'players-on';
    playersHere.dataset.pos = pos;
    bottom.appendChild(playersHere);

    tile.appendChild(bottom);
    cell.appendChild(tile);

    // click handler to view details
    cell.addEventListener('click', () => showProp(pos));
  }

  updatePlayersOnBoard();
}

/* which side */
function determineSide(pos){
  if(pos >= 0 && pos <= 10) return 'top';
  if(pos > 10 && pos <= 20) return 'right';
  if(pos > 20 && pos <= 30) return 'bottom';
  return 'left';
}

/* ---------- Players rendering & updates ---------- */
function renderPlayersList(){
  const list = document.getElementById('turn');
  document.getElementById('turn').textContent = players[currentTurn] ? players[currentTurn].name : '-';
  document.getElementById('money').textContent = 'Rp ' + players[currentTurn].money;
}

function updatePlayersOnBoard(){
  // clear all players-on
  const all = boardEl.querySelectorAll('.players-on');
  all.forEach(el => el.innerHTML = '');
  for(const p of players){
    if(!p.alive) continue;
    const pos = p.pos % MAX_POS;
    const gridIndex = posToIndex[pos];
    const cell = boardEl.children[gridIndex];
    if(!cell) continue;
    const container = cell.querySelector('.players-on');
    if(!container) continue;
    const pawn = document.createElement('span');
    pawn.className = 'pawn';
    pawn.style.background = p.color;
    pawn.title = p.name;
    container.appendChild(pawn);
  }
  // update sidebar info
  document.getElementById('money').textContent = 'Rp ' + players[currentTurn].money;
  document.getElementById('turn').textContent = players[currentTurn].name;
}

/* ---------- Show property info & log ---------- */
function showProp(i){
  const prop = properties[i];
  document.getElementById('tileInfo').textContent = prop.name + (prop.price > 0 ? ' â€¢ Rp ' + prop.price : '');
}
function log(text){
  const p = document.createElement('div');
  p.textContent = text;
  logEl.appendChild(p);
  logEl.scrollTop = logEl.scrollHeight;
}

/* ---------- Game mechanics ---------- */
function rollDice(){
  const p = players[currentTurn];
  if(!p || !p.alive) return;
  diceValue = (Math.floor(Math.random()*6)+1) + (Math.floor(Math.random()*6)+1);
  document.getElementById('dice').textContent = diceValue;
  log(`${p.name} rolled ${diceValue}`);
  movePlayer(currentTurn, diceValue);
  renderPlayersList();
}

function movePlayer(pid, steps){
  const player = players[pid];
  const prev = player.pos;
  player.pos = (player.pos + steps) % MAX_POS;

  // check pass GO
  if(prev + steps >= MAX_POS || player.pos < prev){
    player.money += 200; log(`${player.name} passed GO and collected Rp 200`);
  }

  updatePlayersOnBoard();
  const landed = properties[player.pos];

  if(landed.type === 'tax'){
    player.money -= landed.price || 200;
    log(`${player.name} landed on Tax and paid Rp ${landed.price || 200}`);
    checkBankrupt(player);
  } else if(landed.type === 'chance' || landed.type === 'community'){
    // simple random event
    if(Math.random() < 0.5){ player.money += 100; log(`${player.name} received Rp 100 from ${landed.name}`); }
    else { player.money -= 100; log(`${player.name} lost Rp 100 from ${landed.name}`); checkBankrupt(player); }
  } else if(landed.type === 'gotojail'){
    player.pos = 10; log(`${player.name} sent to Jail`);
  } else if(landed.price === 0){
    log(`${player.name} landed on ${landed.name}`);
  } else if(landed.owner === null){
    log(`${player.name} landed on ${landed.name} â€” available for Rp ${landed.price}`);
    if(player.isAI){
      setTimeout(()=> aiBuyDecision(player.id, landed.id), 550);
    }
  } else if(landed.owner === player.id){
    log(`${player.name} landed on own ${landed.name}`);
  } else {
    const owner = players.find(pl => pl.id === landed.owner);
    const rent = landed.rent;
    player.money -= rent;
    owner.money += rent;
    log(`${player.name} paid Rp ${rent} rent to ${owner.name} (${landed.name})`);
    checkBankrupt(player);
  }
  renderPlayersList();
}

/* buy current */
function buyCurrent(){
  const p = players[currentTurn];
  if(!p || !p.alive) return;
  const prop = properties[p.pos];
  if(!prop || prop.price === 0){ log('Cannot buy this tile.'); return; }
  if(prop.owner !== null){ log('Already owned.'); return; }
  if(p.money >= prop.price){
    p.money -= prop.price;
    prop.owner = p.id;
    log(`${p.name} bought ${prop.name} for Rp ${prop.price}`);
    updatePlayersOnBoard();
    renderPlayersList();
  } else log(`${p.name} cannot afford ${prop.name}`);
}

/* end turn */
function endTurn(){
  const total = players.length;
  let next = currentTurn;
  for(let i=1;i<=total;i++){
    const cand = (currentTurn + i) % total;
    if(players[cand].alive){ next = cand; break; }
  }
  currentTurn = next;
  log(`Turn: ${players[currentTurn].name}`);
  renderPlayersList();
  if(players[currentTurn].isAI){
    setTimeout(()=> runAIMove(players[currentTurn].id), 700);
  }
}

/* bankruptcy */
function checkBankrupt(player){
  if(player.money < 0){
    player.alive = false;
    properties.forEach(prop => { if(prop.owner === player.id) prop.owner = null; });
    log(`${player.name} went bankrupt and is eliminated.`);
    const alive = players.filter(p => p.alive);
    if(alive.length === 1){
      log(`ðŸ† ${alive[0].name} wins!`);
      disableControls();
    } else {
      if(!players[currentTurn].alive) endTurn();
    }
  }
}

/* disable controls on game end */
function disableControls(){
  document.getElementById('rollBtn').disabled = true;
  document.getElementById('buyBtn').disabled = true;
  document.getElementById('endBtn').disabled = true;
}

/* ---------- AI heuristic ---------- */
function aiBuyDecision(aiId, propId){
  const ai = players.find(p=>p.id===aiId);
  const prop = properties[propId];
  if(!ai || !prop || prop.owner !== null) return;
  const price = prop.price;
  const rent = prop.rent;
  const group = findGroup(propId);

  let ownInGroup = 0, totalInGroup = 0;
  if(group){
    totalInGroup = colorGroups[group].length;
    colorGroups[group].forEach(pid => { if(properties[pid].owner === aiId) ownInGroup++; });
  }

  const willHave = ai.money - price;
  let decision = false;
  if(willHave < 150) decision = false;
  else if(group && ownInGroup + 1 === totalInGroup) decision = true; // completes set
  else if(price <= 180) decision = true; // cheap
  else if(rent * 8 > price) decision = true;
  else decision = false;

  if(decision){
    ai.money -= price;
    prop.owner = ai.id;
    log(`${ai.name} bought ${prop.name} (Rp ${price})`);
  } else {
    log(`${ai.name} decided NOT to buy ${prop.name}`);
  }
  renderPlayersList();
}

/* run AI turn end-to-end (roll, decide, end) */
function runAIMove(aiId){
  const idx = players.findIndex(p=>p.id===aiId);
  if(idx === -1) return;
  currentTurn = idx;
  renderPlayersList();
  setTimeout(()=> {
    rollDice();
    setTimeout(()=> { endTurn(); }, 1200);
  }, 300);
}

/* ---------- Controls binding ---------- */
document.getElementById('rollBtn').addEventListener('click', ()=> {
  if(players[currentTurn].isAI) return;
  rollDice();
});
document.getElementById('buyBtn').addEventListener('click', ()=> {
  if(players[currentTurn].isAI) return;
  buyCurrent();
});
document.getElementById('endBtn').addEventListener('click', ()=> {
  if(players[currentTurn].isAI) return;
  endTurn();
});
document.getElementById('addAI').addEventListener('click', ()=> {
  const newId = players.length ? Math.max(...players.map(p=>p.id)) + 1 : 0;
  const colors = ['#a78bfa','#10b981','#f97316','#06b6d4','#c026d3'];
  players.push({id:newId,name:`CPU ${newId}`,color:colors[newId%colors.length]||'#999999',pos:0,money:1500,alive:true,isAI:true});
  log(`Added CPU ${newId}`);
  renderPlayersList();
});
document.getElementById('reset').addEventListener('click', ()=> {
  properties.forEach(p => p.owner = null);
  players = [
    {id:0,name:'You',color:'#ef4444',pos:0,money:1500,alive:true,isAI:false},
    {id:1,name:'CPU 1',color:'#3b82f6',pos:0,money:1500,alive:true,isAI:true}
  ];
  currentTurn = 0;
  diceValue = 0;
  document.getElementById('dice').textContent = '-';
  document.getElementById('tileInfo').textContent = '-';
  logEl.innerHTML = '';
  log('Game reset.');
  renderBoard();
  renderPlayersList();
});

/* ---------- Init ---------- */
renderBoard();
renderPlayersList();
log('Board ready â€” 40 tiles (10 per side). Labels use chosen abbreviations (Prop, Chance, Tax, Rail, Community, Jail, GoToJail). UI below board. Click Roll Dice to play.');

/* expose showProp for initial slot */
function showPropInit(){ showProp(0); }
showPropInit();
</script>
</body>
  </html>
